# Claude Code Global Development Policy
global_instructions: |
  ## CRITICAL: This policy is MANDATORY for ALL projects and sessions

  ### TypeScript Type Safety Requirements
  - **MINIMIZE `any` types**: Only acceptable in extreme cases like `catch (error: unknown)`
  - **Strict typing**: Use proper interfaces, types, and generics instead of `any`
  - **Type assertions**: Avoid `as unknown` or type casting unless absolutely necessary
    - **EXCEPTION**: In tests only, `as unknown as SomeType` is acceptable for mocking purposes
  - **Warning compliance**: Do NOT disable TypeScript warnings or eslint rules as shortcuts

  ### Feature Development Process (MANDATORY)
  Every feature MUST follow this exact process:

  1. **Planning Phase**
    - Define clear requirements and acceptance criteria
    - Break feature into small, testable components
    - Identify dependencies and potential risks

  2. **Iterative Development**
    - **Dependency-Aware Planning**: Always prioritize components with fewer dependencies
      - Build foundational layers first (data models, utilities, core services)
      - Implement dependency-free features before dependent ones
      - Minimize TODOs by building from ground up
    - Advance in small, testable parts (maximum 1-2 hours of work per iteration)
    - Each iteration must be:
      - Compilable without errors
      - Testable in isolation
      - Demonstrably working
    - Test and validate each part before proceeding
    - Fix any issues immediately before moving forward

  3. **Definition of Done**
    A feature is complete ONLY when ALL criteria are met:
    - ✅ Meets ALL stated requirements
    - ✅ Passes ALL tests with minimum 80% code coverage
    - ✅ Entire codebase is in fully working condition
    - ✅ No TypeScript errors or warnings
    - ✅ Code follows established patterns and conventions
    - ✅ Proper error handling implemented
    - ✅ No deprecated functions or APIs used
    - ✅ Documentation updated (if applicable)

  ### Code Quality Standards
  - **KISS Principle**: Keep It Stupidly Simple - prefer readable, straightforward solutions over clever complexity
  - **Testing Discipline**: 
    - ALL tests must pass - no exceptions
    - NEVER delete tests to avoid fixing failures - fix the code or fix the test properly
    - OK to remove redundant or genuinely unnecessary tests (with justification)
    - Mock only what truly needs mocking (external APIs, file systems, databases)
    - Understand the difference between unit tests (isolated) and integration tests (system interactions)
  - **Coverage**: Maintain minimum 80% test coverage for new features
  - **Error Handling**: Implement proper error handling, no silent failures
  - **Documentation**: Add JSDoc comments for public APIs and complex logic
  - **Consistency**: Follow existing project patterns and conventions
  - **No Deprecated Functions**: Never use deprecated APIs, functions, or methods - always use current alternatives

  ### Forbidden Shortcuts
  - ❌ Disabling TypeScript warnings or errors
  - ❌ Using `@ts-ignore` or `@ts-expect-error` without justification
  - ❌ Casting to `unknown` or `any` for convenience (except `as unknown as Type` in tests for mocking)
  - ❌ Skipping tests to "save time"
  - ❌ **Deleting tests to avoid fixing failures** (removing redundant tests is acceptable with justification)
  - ❌ **Over-mocking in unit tests** (mock only external dependencies, not internal logic)
  - ❌ Committing broken or non-compiling code
  - ❌ Reducing test coverage below 80%
  - ❌ Using deprecated functions, APIs, or methods

  ### Session Continuity
  - ALWAYS reference this policy at the start of each session
  - **Agent Selection**: Always analyze the task and select the most appropriate agent(s) for the job
    - **Code Quality**: Use `code-reviewer`, `architect-reviewer`, `refactoring-specialist` for reviews
    - **Testing**: Use `qa-expert`, `test-automator`, `accessibility-tester` for comprehensive testing
    - **Language-Specific**: Use specialized agents like `typescript-pro`, `react-specialist`, `python-pro`
    - **Infrastructure**: Use `devops-engineer`, `cloud-architect`, `security-engineer` for deployment
    - **Debugging**: Use `debugger`, `error-detective`, `performance-engineer` for issue resolution
    - **Meta-Orchestration**: Use `multi-agent-coordinator`, `workflow-orchestrator` for complex workflows
    - Combine specialized agents when tasks span multiple domains
    - Prefer specialized agents over general approaches for better results
  - Confirm understanding of current project state before proceeding
  - Never assume previous context - explicitly verify requirements
  - Document any deviations from this policy with clear justification

  ### Emergency Exceptions
  If absolutely necessary to deviate from this policy:
  1. Explicitly state the deviation and reason
  2. Get explicit confirmation from the developer
  3. Create a technical debt item to address later
  4. Document the exception in code comments

  **Acceptable TODO Comments**: When a required feature dependency hasn't been implemented yet:
  ```typescript
  // TODO: Replace with UserService.validateEmail() once auth module is complete (TICKET-123)
  const isValidEmail = email.includes('@'); // Temporary validation
  ```

  ---

  **REMINDER: Forgetting or ignoring this policy is unacceptable. Always prioritize code quality, testing, and incremental progress over speed.**

# Custom Commands for Business Requirements Analysis
custom_commands:
  requirements:
    description: "Comprehensive business requirements analysis and improvement for MVP"
    prompt: |
      Have multi-agent-coordinator orchestrate a comprehensive business requirements analysis using:
      
      1. business-analyst: Analyze current requirements for completeness, clarity, and feasibility
      2. product-manager: Evaluate business value, priority, and scope alignment  
      3. ux-researcher: Identify user experience gaps and usability considerations
      4. legal-advisor: Check for compliance and regulatory requirements
      5. technical-writer: Ensure requirements are clearly documented and actionable
      
      Focus on:
      - Identifying missing requirements and assumptions
      - Clarifying ambiguous or vague statements  
      - Ensuring testable acceptance criteria
      - Validating business value and user needs
      - Flagging potential technical constraints
      - Suggesting MVP scope refinements
      - Applying dependency-aware planning (build foundational features first)
      
      Provide output as:
      - Analysis summary with key findings
      - Gap identification with specific missing elements
      - Enhanced requirements with acceptance criteria
      - Recommended build order (dependencies first)
      - Next steps and priorities
      
      Requirements to analyze: {input}
    
  req-gaps:
    description: "Identify gaps and missing elements in business requirements"
    prompt: |
      Have business-analyst specifically focus on comprehensive gap analysis for these requirements:
      
      Analyze for missing:
      - Functional requirements (what the system should do)
      - Non-functional requirements (performance, security, usability, scalability)
      - Business rules and constraints
      - User personas and detailed use cases
      - Integration requirements and external dependencies
      - Data requirements (storage, validation, migration)
      - Compliance and regulatory needs
      - Success metrics and KPIs
      - Error handling and edge cases
      - Authentication and authorization needs
      - API requirements and third-party integrations
      - Deployment and infrastructure considerations
      
      Prioritize gaps by:
      - Impact on MVP functionality
      - Dependencies (foundational vs dependent features)
      - Risk level if left unaddressed
      
      Requirements: {input}

  req-validate:
    description: "Validate requirements completeness and quality against development standards"
    prompt: |
      Have qa-expert and business-analyst validate these requirements against our development policy:
      
      Completeness criteria:
      - All user stories have clear, testable acceptance criteria (80%+ test coverage standard)
      - Success metrics are defined and measurable
      - Dependencies and assumptions are documented
      - Risk factors and mitigation strategies identified
      - Build order considers dependency hierarchy
      
      Quality criteria:
      - Requirements are testable and verifiable
      - Language is clear and unambiguous
      - Business value is articulated for each feature
      - Technical feasibility is considered
      - KISS principle applied (simple, clear requirements)
      - No deprecated approaches or technologies
      
      Development alignment:
      - Features can be broken into small, testable increments (1-2 hour iterations)
      - Each requirement supports incremental development
      - Clear error handling requirements specified
      - TypeScript-friendly data structures defined
      
      Requirements: {input}

  req-refine:
    description: "Refine and enhance existing requirements with detailed specifications"
    prompt: |
      Have product-manager and technical-writer work together to refine these requirements:
      
      Enhancement areas:
      - Convert high-level requirements into detailed user stories
      - Add specific acceptance criteria for each story
      - Define data models and interfaces (TypeScript-ready)
      - Specify error conditions and handling
      - Add non-functional requirements (performance, security)
      - Include API specifications where relevant
      - Define testing scenarios and edge cases
      
      Apply our development standards:
      - Ensure requirements support KISS principle
      - Plan for 80%+ test coverage
      - Consider dependency-aware build order
      - Include proper error handling specifications
      - Avoid deprecated technologies or patterns
      
      Output format:
      - Refined user stories with acceptance criteria
      - Technical specifications and data models
      - Testing requirements and scenarios
      - Build order recommendations
      
      Requirements to refine: {input}

  req-tech:
    description: "Technical feasibility analysis for business requirements"
    prompt: |
      Have architect-reviewer and typescript-pro evaluate technical feasibility:
      
      Technical analysis:
      - Architecture implications and design patterns
      - Technology stack recommendations
      - Database design considerations
      - API design and integration requirements
      - Security and compliance implications
      - Performance and scalability considerations
      - Testing strategy and complexity
      
      Development policy alignment:
      - TypeScript implementation approach
      - Dependency management and build order
      - Testing coverage strategy (unit vs integration)
      - Error handling architecture
      - Code quality and maintainability factors
      
      Risk assessment:
      - Technical complexity estimation
      - Potential integration challenges
      - Performance bottlenecks
      - Security vulnerabilities
      - Maintenance and scalability concerns
      
      Recommendations:
      - Preferred implementation approach
      - Technology and framework choices
      - Development phases and milestones
      - Risk mitigation strategies
      
      Requirements for technical analysis: {input}

session_behavior:
  always_check_policy: true
  require_explicit_confirmation: true
  enforce_testing_standards: true
  agent_selection_required: true
  prefer_specialized_agents: true
  minimum_coverage: 80

development_approach: "dependency_aware_incremental"

project_defaults:
  typescript:
    strict: true
    no_any_tolerance: "minimal"
    warning_tolerance: "zero"
  
  testing:
    required: true
    minimum_coverage: 80
    framework_preference: ["jest", "vitest"]
  
  planning_strategy:
    prioritize_foundational_first: true
    minimize_todos: true
    build_order: ["data_models", "utilities", "core_services", "business_logic", "ui_components", "integrations"]

agent_selection_guidelines:
  code_quality: ["code-reviewer", "architect-reviewer", "refactoring-specialist"]
  testing: ["qa-expert", "test-automator", "accessibility-tester", "performance-engineer"]
  typescript: ["typescript-pro", "react-specialist", "nextjs-developer"]
  infrastructure: ["devops-engineer", "cloud-architect", "kubernetes-specialist"]
  security: ["security-engineer", "security-auditor", "penetration-tester"]
  debugging: ["debugger", "error-detective", "error-coordinator"]
  orchestration: ["multi-agent-coordinator", "workflow-orchestrator", "task-distributor"]
  documentation: ["documentation-engineer", "technical-writer", "api-documenter"]
  business_analysis: ["business-analyst", "product-manager", "ux-researcher", "legal-advisor"]

quality_gates:
  - "No TypeScript errors"
  - "All tests passing"
  - "Coverage >= 80%"
  - "No disabled warnings"
  - "No deprecated APIs"
  - "Minimal TODOs with proper justification"
  - "Dependencies built before dependents"
  - "Code reviewed by appropriate agent"
  - "Working codebase state"